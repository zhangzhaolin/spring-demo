### Inversion of Control Containers and the Dependency Injection pattern扎翻译

原文地址：[控制反转和依赖注入](https://www.martinfowler.com/articles/injection.html)

#### 一个简单的例子

从这里开始翻译：
> In this example I'm writing a component that provides a list of movies directed by a particular director. This stunningly useful function is implemented by a single method.

在这个例子中，我正在写一个提供有特定导演指导的电影列表组件，这个非常有用的功能是通过一个方法来实现的。

MovieLister.class
```
  public Movie[] moviesDirectedBy(String arg) {
      List allMovies = finder.findAll();
      for (Iterator it = allMovies.iterator(); it.hasNext();) {
          Movie movie = (Movie) it.next();
          if (!movie.getDirector().equals(arg)) it.remove();
      }
      return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
  }
```
这个函数的实现非常的幼稚，它需要一个```finder```对象（我们很快就知道）返回它的每一场电影，然后遍历```allMovies```，返回由特定导演指导的电影。我不会去修补这个天真的代码，因为这是本文真正意义上的基础。

这篇文章的真正要点就是这个```finder```对象，或者尤其说我们如何将list和finder对象连接起来。我希望```moviesDirectedBy```方法可以和所有电影的存储方法完全独立，所以所有的方法都会引用```finder```对象，并且```finder```对象也会知道如何返回```findAll```方法，我可以定义一个有关于```finder```的接口来解决这个问题

```
public interface MovieFinder {
    List findAll();
}
```

目前这些都很好的解耦，但是在某些时候，我需要想出一个具体的类来存放这些电影，在这种情况下，我把这些放到了我的lister构造器中。

MovieLister.class
```
public MovieLister() {
    finder = new ColonDelimitedMovieFinder("movies1.txt");
}
```

总代码如下：

MovieLister.class类
```
public class MoveiLister{

    private MovieFinder find;
    
    public MoveiLister(){
        finder = new ColonDelimitedMovieFinder("movies1.txt");
    }
    
    public Movie[] moviesDirectedBy(String arg) {
      List allMovies = finder.findAll();
      for (Iterator it = allMovies.iterator(); it.hasNext();) {
          Movie movie = (Movie) it.next();
          if (!movie.getDirector().equals(arg)) it.remove();
      }
      return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
  }
}
```
MovieFinder.class类
```
public interfave MovieFinder{
    List findAll();
}
```

实现类的名称来源于我从冒号分割的文本中获取我的列表，我会告诉你细节，毕竟只是一些实现。

现在，如果只是我自己而使用这个类，一切都很好很正常。但是，当我的朋友非常渴望拷贝一份我的代码的时候会发生什么事情呢？如果他们还把电影列表存储在```movies1.txt```中，那么一切都很美妙。如果他们的存放电影文件的命名不同，那么把文件名称放到一个配置文件中，也很容易。但是，如果他们有一个完全不同的形式存储电影列表：SQL数据库，XML文件，或者其他格式的文件呢？因为现在，我已经定义了一个```MovieFinder```接口，这不会改变我的```moviesDirectedBy```方法，但是我仍然需要一些路子，来定义```finder```

[1]: https://www.martinfowler.com/articles/injection/naive.gif
 ![图1: 在列表类中使用简单创建的依赖关系][1]
图1: 在列表类中使用简单创建的依赖关系

>Figure 1 shows the dependencies for this situation. The MovieLister class is dependent on both the MovieFinder interface and upon the implementation. We would prefer it if it were only dependent on the interface, but then how do we make an instance to work with?
In my book P of EAA, we described this situation as a Plugin. The implementation class for the finder isn't linked into the program at compile time, since I don't know what my friends are going to use. Instead we want my lister to work with any implementation, and for that implementation to be plugged in at some later point, out of my hands. The problem is how can I make that link so that my lister class is ignorant of the implementation class, but can still talk to an instance to do its work.
Expanding this into a real system, we might have dozens of such services and components. In each case we can abstract our use of these components by talking to them through an interface (and using an adapter if the component isn't designed with an interface in mind). But if we wish to deploy this system in different ways, we need to use plugins to handle the interaction with these services so we can use different implementations in different deployments.
So the core problem is how do we assemble these plugins into an application? This is one of the main problems that this new breed of lightweight containers face, and universally they all do it using Inversion of Control.

图一显示了这种情况的依赖关系，```MovieLister```类依赖于```MovieFinder```接口和实现。如果```MovieLister```类只依赖接口的话，我们会更喜欢它，所以我们该怎么做呢？

在我的一本书中 [P of EAA](https://www.martinfowler.com/books/eaa.html)，我们把这种情况称为一个插件，```finder```的实现类在编译时没有链接到程序中，因为我不知道我的朋友们将使用什么。相反，我希望我的lister能够和任何```finder```实现类一起工作，并且```finder```实现类将会自动的插入到程序中，而不是通过我来掌控。问题是我应该怎样完成这些链接，以便我的```lister```类对实现类是无知的，但是它依然可以和一个实例完成工作。

把这些扩展成一个真正的系统，或许我们需要很多这样的服务和组件。在每一种情况下，我们可以通过一个接口（如果组件没有设计接口的话，可以使用组件），来让我们的组件相互关联。但是如果我们希望通过不同的方式部署这个系统，我们需要使用插件来处理这些服务的交互以便于我们可以在不同的部署中使用不同的实现。

所以核心问题是我们如何将这些插件组装到应用文件之中？这也是一些轻量级容器所面临的主要问题之一，并且通常他们都是通过控制反转来实现的。

#### 控制反转
当这些容器谈到他们如何有用，他们说是因为实现了“控制反转”时候，我感到诧异。控制反转是框架的一个共同特征，所以说这些轻量级框架是特殊的，因为他们使用了控制反转。这就像说我的车是特殊的因为它有车轮。
问题是：“他们反转的是哪些方面的控制？”，当我第一次遇到控制反转的时候，它是在用户界面的主要控制之下。早期的用户界面是被应用程序所控制，你会有一系列如“输入名称”，”输入地址”的命令；你的程序将推动提示并受到各个响应。使用图形（甚至基于屏幕的）UI，UI框架将会包含这个主循环，并且，你的程序将会提供事件处理程序来代替屏幕上的各个区域。这个程序的主要控制权被颠倒了，从你转移到了框架。
因此，我认为西门需要一个更具体的名称来表示这种模式，控制反转（Inversion of Control）是一个过于笼统的术语，因此人们感到困惑。因此与很多IOC提倡者进行了大量讨论之后，我们决定使用Dependency Injection（DI 依赖注入）这个词。
我将开始讨论各种形式的依赖注入，但是我想指出的是，使用插件实现来去除依赖并不是应用程序类的唯一方法。你可以使用的另一种模式是服务定位器模式，在完成解释依赖注入之后，我会讨论这个问题。

#### 依赖注入的形式
